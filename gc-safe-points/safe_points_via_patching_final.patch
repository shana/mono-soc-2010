Index: mono/metadata/sgen-gc.c
===================================================================
--- mono/metadata/sgen-gc.c	(revision 159364)
+++ mono/metadata/sgen-gc.c	(working copy)
@@ -5213,8 +5213,15 @@
 
 #if USE_SIGNAL_BASED_START_STOP_WORLD
 
-static MonoSemType suspend_ack_semaphore;
-static MonoSemType *suspend_ack_semaphore_ptr;
+static MonoSemType ack_semaphore_a;
+static MonoSemType *ack_semaphore_a_ptr;
+
+/* Two semaphores needed for syncing in safe safe points. */
+#ifdef MONO_GC_SAFE_POINTS
+static MonoSemType ack_semaphore_b;
+static MonoSemType *ack_semaphore_b_ptr;
+#endif
+
 static unsigned int global_stop_count = 0;
 
 static sigset_t suspend_signal_mask;
@@ -5279,16 +5286,18 @@
 #endif
 #endif
 
+#ifndef MONO_GC_SAFE_POINTS
 static gboolean
 is_ip_in_managed_allocator (MonoDomain *domain, gpointer ip);
+#endif
 
 void
-mono_sgen_wait_for_suspend_ack (int count)
+mono_sgen_wait_for_suspend_ack (int count, MonoSemType *sem_ptr)
 {
 	int i, result;
 
 	for (i = 0; i < count; ++i) {
-		while ((result = MONO_SEM_WAIT (suspend_ack_semaphore_ptr)) != 0) {
+		while ((result = MONO_SEM_WAIT (sem_ptr)) != 0) {
 			if (errno != EINTR) {
 				g_error ("sem_wait ()");
 			}
@@ -5296,6 +5305,8 @@
 	}
 }
 
+#ifndef MONO_GC_SAFE_POINTS
+
 static int
 restart_threads_until_none_in_managed_allocator (void)
 {
@@ -5343,7 +5354,7 @@
 		/* mach thread_resume is synchronous so we dont need to wait for them */
 #else
 		/* wait for the threads to signal their restart */
-		mono_sgen_wait_for_suspend_ack (restart_count);
+		mono_sgen_wait_for_suspend_ack (restart_count, ack_semaphore_a_ptr);
 #endif
 
 		if (sleep_duration < 0) {
@@ -5378,28 +5389,43 @@
 #else
 		/* wait for the threads to signal their suspension
 		   again */
-		mono_sgen_wait_for_suspend_ack (restart_count);
+		mono_sgen_wait_for_suspend_ack (restart_count, ack_semaphore_a_ptr);
 #endif
 	}
 
 	return num_threads_died;
 }
 
-/* LOCKING: assumes the GC lock is held (by the stopping thread) */
+#endif /* !MONO_GC_SAFE_POINTS */
+
+/* Used at several places when using safe points. */
 static void
-suspend_handler (int sig, siginfo_t *siginfo, void *context)
+wait_for_restart_signal (SgenThreadInfo *info)
 {
+	/* wait until we receive the restart signal */
+	do {
+		info->signal = 0;
+		sigsuspend (&suspend_signal_mask);
+	} while (info->signal != restart_signal_num);
+}
+
+/* LOCKING: assumes the GC lock is held (by the stopping thread) */
+/* When using safe points, note that only the registers (machine state)
+ * are guaranteed to be correct. */
+void
+mono_sgen_thread_ready_to_suspend (void *context)
+{
 	SgenThreadInfo *info;
-	pthread_t id;
 	int stop_count;
 	int old_errno = errno;
 	gpointer regs [ARCH_NUM_REGS];
 	gpointer stack_start;
 
-	id = pthread_self ();
-	info = mono_sgen_thread_info_lookup (id);
+	info = mono_sgen_thread_info_lookup (ARCH_GET_THREAD ());
+#ifndef MONO_GC_SAFE_POINTS
 	info->stopped_domain = mono_domain_get ();
 	info->stopped_ip = (gpointer) ARCH_SIGCTX_IP (context);
+#endif
 	stop_count = global_stop_count;
 	/* duplicate signal */
 	if (0 && info->stop_count == stop_count) {
@@ -5422,35 +5448,64 @@
 		g_assert (!info->stack_start);
 	}
 
-	/* Notify the JIT */
-	if (gc_callbacks.thread_suspend_func)
-		gc_callbacks.thread_suspend_func (info->runtime_data, context);
+	DEBUG (4, fprintf (gc_debug_file, "Posting suspend_ack_semaphore for suspend from %p %p\n", info, (gpointer)ARCH_GET_THREAD ()));
 
-	DEBUG (4, fprintf (gc_debug_file, "Posting suspend_ack_semaphore for suspend from %p %p\n", info, (gpointer)ARCH_GET_THREAD ()));
-	/* notify the waiting thread */
-	MONO_SEM_POST (suspend_ack_semaphore_ptr);
+#ifdef MONO_GC_SAFE_POINTS
+	MONO_SEM_POST (ack_semaphore_b_ptr);
+#else
+	MONO_SEM_POST (ack_semaphore_a_ptr);
+#endif
+
 	info->stop_count = stop_count;
 
-	/* wait until we receive the restart signal */
-	do {
-		info->signal = 0;
-		sigsuspend (&suspend_signal_mask);
-	} while (info->signal != restart_signal_num);
+	wait_for_restart_signal (info);
 
 	DEBUG (4, fprintf (gc_debug_file, "Posting suspend_ack_semaphore for resume from %p %p\n", info, (gpointer)ARCH_GET_THREAD ()));
 	/* notify the waiting thread */
-	MONO_SEM_POST (suspend_ack_semaphore_ptr);
 
+	MONO_SEM_POST (ack_semaphore_a_ptr);
+
 	errno = old_errno;
+
+#ifdef MONO_GC_SAFE_POINTS
+	g_assert (gc_callbacks.thread_resume_func);
+	gc_callbacks.thread_resume_func (info->runtime_data);
+
+	wait_for_restart_signal (info);
+	MONO_SEM_POST (ack_semaphore_b_ptr);
+#endif
 }
 
+/* LOCKING: assumes the GC lock is held (by the stopping thread) */
 static void
+suspend_handler (int sig, siginfo_t *siginfo, void *context)
+{
+#ifdef MONO_GC_SAFE_POINTS
+	SgenThreadInfo *info = mono_sgen_thread_info_lookup (ARCH_GET_THREAD ());
+
+	g_assert (gc_callbacks.thread_prepare_park_func);
+
+	MONO_SEM_POST (ack_semaphore_a_ptr);
+	wait_for_restart_signal (info);
+
+	if (!mono_thread_internal_current () ||
+			gc_callbacks.thread_prepare_park_func (mono_sgen_thread_info_lookup (ARCH_GET_THREAD ())->runtime_data, context)) {
+		if (!mono_thread_internal_current ()) 
+			g_warning ("mono_internal_thread_current == NULL. Suspending anyways.");
+		mono_sgen_thread_ready_to_suspend (context);
+	}
+#else
+	mono_sgen_thread_ready_to_suspend (context);
+#endif
+}
+
+static void
 restart_handler (int sig)
 {
 	SgenThreadInfo *info;
 	int old_errno = errno;
 
-	info = mono_sgen_thread_info_lookup (pthread_self ());
+	info = mono_sgen_thread_info_lookup (ARCH_GET_THREAD ());
 	info->signal = restart_signal_num;
 	DEBUG (4, fprintf (gc_debug_file, "Restart handler in %p %p\n", info, (gpointer)ARCH_GET_THREAD ()));
 
@@ -5485,8 +5540,15 @@
 	global_stop_count++;
 	DEBUG (3, fprintf (gc_debug_file, "stopping world n %d from %p %p\n", global_stop_count, mono_sgen_thread_info_lookup (ARCH_GET_THREAD ()), (gpointer)ARCH_GET_THREAD ()));
 	TV_GETTIME (stop_world_time);
-	count = mono_sgen_thread_handshake (suspend_signal_num);
+#ifdef MONO_GC_SAFE_POINTS
+	g_assert (gc_callbacks.thread_initiate_parking);
+	gc_callbacks.thread_initiate_parking (mono_sgen_thread_info_lookup (ARCH_GET_THREAD ())->runtime_data);
+	count = mono_sgen_thread_handshake (suspend_signal_num, ack_semaphore_a_ptr);
+	g_assert (mono_sgen_thread_handshake (restart_signal_num, ack_semaphore_b_ptr) == count);
+#else
+	count = mono_sgen_thread_handshake (suspend_signal_num, ack_semaphore_a_ptr);
 	count -= restart_threads_until_none_in_managed_allocator ();
+#endif
 	g_assert (count >= 0);
 	DEBUG (3, fprintf (gc_debug_file, "world stopped %d thread(s)\n", count));
 	return count;
@@ -5517,7 +5579,28 @@
 
 	release_gc_locks ();
 
-	count = mono_sgen_thread_handshake (restart_signal_num);
+#ifdef MONO_GC_SAFE_POINTS
+	{
+		ARCH_THREAD_TYPE me = ARCH_GET_THREAD ();
+
+		g_assert (gc_callbacks.thread_dissolve_parking);
+		gc_callbacks.thread_dissolve_parking (mono_sgen_thread_info_lookup (me)->runtime_data);
+
+		g_assert (gc_callbacks.thread_resume_prepare_func);
+		for (i = 0; i < THREAD_HASH_SIZE; ++i) {
+			for (info = thread_table [i]; info; info = info->next) {
+				if (ARCH_THREAD_EQUALS (info->id, me))
+					continue;
+				gc_callbacks.thread_resume_prepare_func (info->runtime_data);
+			}
+		}
+	}
+#endif
+
+	count = mono_sgen_thread_handshake (restart_signal_num, ack_semaphore_a_ptr);
+#ifdef MONO_GC_SAFE_POINTS
+	g_assert (count == mono_sgen_thread_handshake (restart_signal_num, ack_semaphore_b_ptr));
+#endif
 	TV_GETTIME (end_sw);
 	usec = TV_ELAPSED (stop_world_time, end_sw);
 	max_pause_usec = MAX (usec, max_pause_usec);
@@ -6000,8 +6083,10 @@
 	info->tlab_real_end_addr = &TLAB_REAL_END;
 	info->store_remset_buffer_addr = &STORE_REMSET_BUFFER;
 	info->store_remset_buffer_index_addr = &STORE_REMSET_BUFFER_INDEX;
+#ifndef MONO_GC_SAFE_POINTS
 	info->stopped_ip = NULL;
 	info->stopped_domain = NULL;
+#endif
 	info->stopped_regs = NULL;
 
 	binary_protocol_thread_register ((gpointer)info->id);
@@ -6107,6 +6192,10 @@
 	}
 	if (*p->store_remset_buffer_index_addr)
 		add_generic_store_remset_from_buffer (*p->store_remset_buffer_addr);
+#ifdef MONO_GC_SAFE_POINTS
+	g_assert (gc_callbacks.thread_detach_func);
+	gc_callbacks.thread_detach_func (p->runtime_data);
+#endif
 	free_internal_mem (*p->store_remset_buffer_addr, INTERNAL_MEM_STORE_REMSET);
 	free (p);
 }
@@ -7195,9 +7284,14 @@
 		g_strfreev (opts);
 	}
 
-	suspend_ack_semaphore_ptr = &suspend_ack_semaphore;
-	MONO_SEM_INIT (&suspend_ack_semaphore, 0);
+	ack_semaphore_a_ptr = &ack_semaphore_a;
+	MONO_SEM_INIT (&ack_semaphore_a, 0);
 
+#ifdef MONO_GC_SAFE_POINTS
+	ack_semaphore_b_ptr = &ack_semaphore_b;
+	MONO_SEM_INIT (&ack_semaphore_b, 0);
+#endif
+
 	sigfillset (&sinfo.sa_mask);
 	sinfo.sa_flags = SA_RESTART | SA_SIGINFO;
 	sinfo.sa_sigaction = suspend_handler;
@@ -7496,6 +7590,20 @@
 static MonoMethod* alloc_method_cache [ATYPE_NUM];
 static MonoMethod *write_barrier_method;
 
+gboolean
+mono_sgen_is_inconsistent_method (MonoMethod *method)
+{
+	int i;
+	if (method == write_barrier_method)
+		return TRUE;
+	for (i = 0; i < ATYPE_NUM; ++i)
+		if (method == alloc_method_cache [i])
+			return TRUE;
+	return FALSE;
+}
+
+#ifndef MONO_GC_SAFE_POINTS
+
 static gboolean
 is_ip_in_managed_allocator (MonoDomain *domain, gpointer ip)
 {
@@ -7510,14 +7618,11 @@
 		return FALSE;
 	method = ji->method;
 
-	if (method == write_barrier_method)
-		return TRUE;
-	for (i = 0; i < ATYPE_NUM; ++i)
-		if (method == alloc_method_cache [i])
-			return TRUE;
-	return FALSE;
+	return mono_sgen_is_inconsistent_method (method);
 }
 
+#endif
+
 /*
  * Generate an allocator method implementing the fast path of mono_gc_alloc_obj ().
  * The signature of the called method is:
Index: mono/metadata/sgen-gc.h
===================================================================
--- mono/metadata/sgen-gc.h	(revision 159364)
+++ mono/metadata/sgen-gc.h	(working copy)
@@ -24,14 +24,22 @@
 #ifndef __MONO_SGENGC_H__
 #define __MONO_SGENGC_H__
 
+#include <mono/metadata/metadata.h>
+
 /* pthread impl */
 #include "config.h"
 #include <glib.h>
 #include <pthread.h>
 #include <sys/signal.h>
-#include "utils/mono-compiler.h"
-#include "metadata/class-internals.h"
+#include <mono/utils/mono-compiler.h>
+#include <mono/utils/mono-semaphore.h>
+#include <mono/metadata/class-internals.h>
 
+/* Doing a #include "metadata/class-internals.h" breaks mini-gc.c build.
+ * This needs to included in mini-gc.c since otherwise MONO_GC_SAFE_POINTS
+ * is not defined. This may be done away with by having autoheader define
+ * MONO_GC_SAFE_POINTS in config.h. */
+
 #define THREAD_HASH_SIZE 11
 
 #define ARCH_THREAD_TYPE pthread_t
@@ -44,6 +52,12 @@
 typedef guint64 mword;
 #endif
 
+/* Define this to use GC safe points. */
+#define MONO_GC_SAFE_POINTS 1
+
+//#define DEBUG_SAFE_POINTS(...) fprintf (stderr, __VA_ARGS__);
+#define DEBUG_SAFE_POINTS(...) 
+
 /* for use with write barriers */
 typedef struct _RememberedSet RememberedSet;
 struct _RememberedSet {
@@ -74,8 +88,10 @@
 	long *store_remset_buffer_index_addr;
 	RememberedSet *remset;
 	gpointer runtime_data;
+#ifndef MONO_GC_SAFE_POINTS /* Not needed if safe points are being used. */
 	gpointer stopped_ip;	/* only valid if the thread is stopped */
 	MonoDomain *stopped_domain; /* ditto */
+#endif
 	gpointer *stopped_regs;	    /* ditto */
 #ifndef HAVE_KW_THREAD
 	char *tlab_start;
@@ -87,12 +103,16 @@
 #endif
 };
 
+gboolean mono_sgen_is_inconsistent_method (MonoMethod *);
+
+/* const to prevent 'foo defined but not used' warnings. */
+
 #ifdef __APPLE__
-static int suspend_signal_num = SIGXFSZ;
+const static int suspend_signal_num = SIGXFSZ;
 #else
-static int suspend_signal_num = SIGPWR;
+const static int suspend_signal_num = SIGPWR;
 #endif
-static int restart_signal_num = SIGXCPU;
+const static int restart_signal_num = SIGXCPU;
 
 /*
  * Recursion is not allowed for the thread lock.
@@ -112,10 +132,10 @@
 #define MAX_DEBUG_LEVEL 2
 #define DEBUG(level,a) do {if (G_UNLIKELY ((level) <= MAX_DEBUG_LEVEL && (level) <= gc_debug_level)) a;} while (0)
 
-int mono_sgen_thread_handshake (int signum) MONO_INTERNAL;
+int mono_sgen_thread_handshake (int signum, MonoSemType *sem_ptr) MONO_INTERNAL;
 SgenThreadInfo* mono_sgen_thread_info_lookup (ARCH_THREAD_TYPE id) MONO_INTERNAL;
 SgenThreadInfo** mono_sgen_get_thread_table (void) MONO_INTERNAL;
-void mono_sgen_wait_for_suspend_ack (int count) MONO_INTERNAL;
+void mono_sgen_wait_for_suspend_ack (int count, MonoSemType *sem_ptr) MONO_INTERNAL;
 
 #endif /* __MONO_SGENGC_H__ */
 
Index: mono/metadata/gc-internal.h
===================================================================
--- mono/metadata/gc-internal.h	(revision 159364)
+++ mono/metadata/gc-internal.h	(working copy)
@@ -193,16 +193,37 @@
 	 * by attach_func. This might called with GC locks held and the word stopped,
 	 * so it shouldn't do any synchronization etc.
 	 */
-	void (*thread_suspend_func) (gpointer user_data, void *sigcontext);
+	void (*thread_suspend_func) (gpointer user_data, gpointer sigcontext);
 	/* 
 	 * Function called to mark from thread stacks. user_data is the data returned 
-	 * by attach_func. This is called twice, with the word stopped:
+	 * by attach_func. This is called twice, with the world stopped:
 	 * - in the first pass, it should mark areas of the stack using
 	 *   conservative marking by calling mono_gc_conservatively_scan_area ().
 	 * - in the second pass, it should mark the remaining areas of the stack
 	 *   using precise marking by calling mono_gc_scan_object ().
 	 */
 	void (*thread_mark_func) (gpointer user_data, guint8 *stack_start, guint8 *stack_end, gboolean precise);
+
+	/* To be called from the collecting thread to before stopping the world. */
+	void (*thread_initiate_parking) (gpointer user_data);
+
+	/* To be called from the collecting thread to before re-starting the world. */
+	void (*thread_dissolve_parking) (gpointer user_data);
+
+	/* Called to prepare a thread for parking. This has to be called from the thread 
+	 * about to be parked. */
+	gboolean (*thread_prepare_park_func) (gpointer user_data, gpointer context);
+
+	/* This should be called to make a thread ready to be re-started. This may be called from any thread
+	 * provided the correct user_data is passed. */
+	void (*thread_resume_prepare_func) (gpointer user_data);
+
+	/* Call from the thread to be resumed. This can only be called when thread_resume_prepare_func
+	 * has been called for *all* threads. */
+	void (*thread_resume_func) (gpointer user_data);
+
+	/* Called from a when unregistering itself. */
+	void (*thread_detach_func) (gpointer);
 } MonoGCCallbacks;
 
 /* Set the callback functions callable by the GC */
@@ -229,7 +250,14 @@
 void* mono_gc_invoke_with_gc_lock (MonoGCLockedCallbackFunc func, void *data) MONO_INTERNAL;
 
 #ifdef HAVE_SGEN_GC
+
+/*
+ * Called to tell SGen that the thread is ready to be suspended. 
+ */
+void mono_sgen_thread_ready_to_suspend (void *context);
+
 int mono_gc_get_los_limit (void) MONO_INTERNAL;
+
 #endif
 
 #endif /* __MONO_METADATA_GC_INTERNAL_H__ */
Index: mono/metadata/sgen-os-posix.c
===================================================================
--- mono/metadata/sgen-os-posix.c	(revision 159364)
+++ mono/metadata/sgen-os-posix.c	(working copy)
@@ -38,7 +38,7 @@
 
 #if !defined(__MACH__) && !MONO_MACH_ARCH_SUPPORTED
 int
-mono_sgen_thread_handshake (int signum)
+mono_sgen_thread_handshake (int signum, MonoSemType *sem_ptr)
 {
 	int count, i, result;
 	SgenThreadInfo **thread_table;
@@ -63,7 +63,7 @@
 		}
 	}
 
-	mono_sgen_wait_for_suspend_ack (count);
+	mono_sgen_wait_for_suspend_ack (count, sem_ptr);
 
 	return count;
 }
Index: mono/mini/mini.c
===================================================================
--- mono/mini/mini.c	(revision 159364)
+++ mono/mini/mini.c	(working copy)
@@ -3280,6 +3280,16 @@
 
 	mono_debug_open_method (cfg);
 
+#ifdef MONO_GC_SAFE_POINTS
+{
+	int i;
+	for (i = 0; i < SAFE_POINT_TYPE_MAX; i++) {
+		cfg->safe_points_tail [i] = cfg->safe_points_head [i] = NULL;
+		cfg->safe_points_num [i] = 0;
+	}
+}
+#endif
+
 	/* emit code all basic blocks */
 	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
 		bb->native_offset = cfg->code_len;
@@ -3301,6 +3311,17 @@
 		}
 	}
 
+#ifdef MONO_GC_SAFE_POINTS
+{
+	int i;
+	for (i = 0; i < SAFE_POINT_TYPE_MAX; i++) {
+		if (cfg->safe_points_tail [i]) {
+			cfg->safe_points_tail [i]->next = NULL; 
+		}
+	}
+}
+#endif
+
 	mono_arch_emit_exceptions (cfg);
 
 	max_epilog_size = 0;
@@ -3402,6 +3423,51 @@
 	}
 }
 
+#ifdef MONO_GC_SAFE_POINTS
+
+static const char *
+safe_point_reason_to_string (MonoSafePointReason reason)
+{
+	switch (reason) {
+	case SAFE_POINT_TYPE_BACKWARD_BRANCH:
+		return "backward_branch";
+	case SAFE_POINT_TYPE_METHOD_CALL:
+		return "method_call";
+	case SAFE_POINT_TYPE_RETURN:
+		return "return";
+	default:
+		g_assert_not_reached ();
+	}
+}
+
+static void
+prepare_safe_point_jit_info (MonoJitInfo *jinfo, MonoCompile *cfg)
+{
+	MonoGCInfo *safe_point_set = g_malloc (sizeof (MonoGCInfo));
+	MonoSafePointCfgInfo *iter = NULL;
+	int i, j;
+
+//	DEBUG_SAFE_POINTS ("Preparing safe point JIT info for %s.\n", mono_method_full_name (cfg->method, FALSE));
+
+	for (i = 0; i < SAFE_POINT_TYPE_MAX; i++) {
+		MonoSafePointJitInfo *safe_points = g_malloc (sizeof (MonoSafePointJitInfo) * cfg->safe_points_num [i]);
+		for (j = 0, iter = cfg->safe_points_head [i]; iter; iter = iter->next, j++) {
+			if (j >= cfg->safe_points_num [i])
+				break; // FIXME Figure out what causes a non NULL next in tail
+			safe_points [j].native_offset = iter->native_offset;
+			safe_points [j].op = iter->op;
+			safe_points [j].reason = iter->reason;
+			g_assert (iter->reason == i);
+		}
+		safe_point_set->safe_points [i] = safe_points;
+		safe_point_set->safe_points_len [i] = cfg->safe_points_num [i];
+	}
+
+	jinfo->gc_info = safe_point_set;
+}
+
+#endif
+
 static MonoJitInfo*
 create_jit_info (MonoCompile *cfg, MonoMethod *method_to_compile)
 {
@@ -3639,6 +3705,10 @@
 	}
 #endif
 
+#ifdef MONO_GC_SAFE_POINTS
+	prepare_safe_point_jit_info (jinfo, cfg);
+#endif
+
 	return jinfo;
 }
 #endif
@@ -3917,8 +3987,6 @@
 		cfg->compute_precise_live_ranges = TRUE;
 	}
 
-	mini_gc_init_gc_map (cfg);
-
 	if (COMPILE_LLVM (cfg)) {
 		cfg->opt |= MONO_OPT_ABCREM;
 	}
@@ -4475,8 +4543,6 @@
 
 	mono_save_xdebug_info (cfg);
 
-	mini_gc_create_gc_map (cfg);
- 
 	mono_save_seq_point_info (cfg);
 
 	if (!cfg->compile_aot) {
@@ -5006,8 +5072,26 @@
 	 */
 	mono_jit_info_table_remove (domain, ji->ji);
 
-	if (destroy)
+	if (destroy) {
 		mono_code_manager_destroy (ji->code_mp);
+#ifdef MONO_GC_SAFE_POINTS
+		{
+			MonoGCInfo *safe_point_set = ji->ji->gc_info;
+			int k;
+			for (k = 0; k < SAFE_POINT_TYPE_MAX; k++) {
+				int i;
+				MonoSafePointJitInfo *safe_points = safe_point_set->safe_points [k];
+				for (i = 0; i < safe_point_set->safe_points_len [k]; i++) {
+					/* Will have to eventually write a stack_map_destroy function and probably
+					 * move this block to a separate function too. */
+				}
+				g_free (safe_points);
+			}
+			g_free (safe_point_set);
+			ji->ji->gc_info = NULL;
+		}
+#endif
+	}
 	g_free (ji);
 }
 
@@ -6308,6 +6392,93 @@
 	g_hash_table_destroy (assemblies);
 }
 
+#ifdef MONO_GC_SAFE_POINTS
+
+#define INCLUDE_OP_IN_DESCRIPTION
+#ifdef INCLUDE_OP_IN_DESCRIPTION
+
+#define MINI_OP(a,b,c,d,e) b,
+#define MINI_OP3(a,b,c,d,e,f) b,
+
+static const char *__ir_op [] = {
+#include "mono/mini/mini-ops.h"
+};
+
+#undef MINI_OP
+#undef MINI_OP3
+
+#endif
+
+gchar *
+mono_jit_safe_point_descr (MonoSafePointJitInfo *info)
+{
+#ifdef INCLUDE_OP_IN_DESCRIPTION
+	if (info->op == -1) {
+		/* STORE_SAFE_POINT_INFO (cfg, code, FOO, -1) for debugging */
+		return g_strdup_printf ("(jit safe pt. %s 0x%x DEBUG)", safe_point_reason_to_string (info->reason), info->native_offset);
+	} else if (info->op) {
+		g_assert (info->op >= MONO_CEE_LAST);
+		return g_strdup_printf ("(jit safe pt. %s 0x%x %s)", safe_point_reason_to_string (info->reason), info->native_offset, __ir_op [info->op - MONO_CEE_LAST]);
+	} else {
+		return g_strdup_printf ("(jit safe pt. %s 0x%x nil)", safe_point_reason_to_string (info->reason), info->native_offset);
+	}
+#else
+	return g_strdup_printf ("(jit safe pt. %s 0x%x)", safe_point_reason_to_string (info->reason), info->native_offset);
+#endif
+}
+
+gboolean
+mono_is_safe_point (const MonoInst *inst, const MonoCompile *cfg, const guint8 *code, MonoSafePointReason *reason)
+{
+	guint16 op = inst->opcode;
+	long code_offset = code - cfg->native_code;
+
+	g_assert (reason);
+
+#if 0
+	if (op == OP_BR && inst->inst_target_bb == cfg->bb_exit) {
+		*reason = SAFE_POINT_TYPE_RETURN;
+		return TRUE;
+	}
+#endif
+
+	if ((op >= OP_VOIDCALL && op <= OP_DYN_CALL) || op == OP_JMP || op == OP_TAILCALL) {
+		*reason = SAFE_POINT_TYPE_METHOD_CALL;
+		return TRUE;
+	}
+
+	if (op == OP_BR && inst->inst_target_bb->native_offset && inst->inst_target_bb->native_offset && code_offset > inst->inst_target_bb->native_offset) {
+		*reason = SAFE_POINT_TYPE_BACKWARD_BRANCH;
+		return TRUE;
+	}
+
+	if ((op >= OP_IBEQ && op <= OP_IBLT_UN) && inst->inst_true_bb->native_offset && code_offset > inst->inst_true_bb->native_offset) {
+		*reason = SAFE_POINT_TYPE_BACKWARD_BRANCH;
+		return TRUE;
+	}
+
+	if ((op >= OP_LBEQ && op <= OP_LBLT_UN) && inst->inst_true_bb->native_offset && code_offset > inst->inst_true_bb->native_offset) {
+		*reason = SAFE_POINT_TYPE_BACKWARD_BRANCH;
+		return TRUE;
+	}
+
+	if ((op >= OP_FBEQ && op <= OP_FBLT_UN) && inst->inst_true_bb->native_offset && code_offset > inst->inst_true_bb->native_offset) {
+		*reason = SAFE_POINT_TYPE_BACKWARD_BRANCH;
+		return TRUE;
+	}
+
+	if (op == OP_BR_REG) { /* Can't take chances. */
+		*reason = SAFE_POINT_TYPE_BACKWARD_BRANCH;
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+// TODO Figure out a way to denote a safe region (or something) later.
+
+#endif // MONO_GC_SAFE_POINTS
+
 #ifndef DISABLE_JIT
 
 void*
Index: mono/mini/mini.h
===================================================================
--- mono/mini/mini.h	(revision 159364)
+++ mono/mini/mini.h	(working copy)
@@ -17,7 +17,12 @@
 #include <mono/metadata/profiler-private.h>
 #include <mono/metadata/debug-helpers.h>
 #include <mono/utils/mono-compiler.h>
+#include <mono/metadata/gc-internal.h>
 
+#ifdef HAVE_SGEN_GC
+#include <mono/metadata/sgen-gc.h>
+#endif
+
 #define MONO_BREAKPOINT_ARRAY_SIZE 64
 
 /* C type matching the size of a machine register. Not always the same as 'int' */
@@ -443,6 +448,52 @@
 	int offset;
 };
 
+typedef enum {
+	SAFE_POINT_TYPE_BACKWARD_BRANCH,
+	SAFE_POINT_TYPE_METHOD_CALL,
+	SAFE_POINT_TYPE_RETURN,
+	SAFE_POINT_TYPE_MAX
+} MonoSafePointReason;
+
+/**
+ * Holds the GC map for a stack frame at a particular safe point.
+ * This is created from the corresponding MonoSafePointCfgInfo structures in 
+ * create_jit_info.
+ **/
+typedef struct {
+	guint native_offset;
+//	GCStackMap *stack_map;
+	MonoSafePointReason reason;
+	int op;
+} MonoSafePointJitInfo;
+
+/**
+ * Represents a safe point inside the control flow graph (MonoCompile).
+ **/
+typedef struct MonoSafePointCfgInfo {
+	guint native_offset; /* Offset of the native IP where the corresponding OP_SAFE_POINT
+			     * instruction has been inserted. */
+	int id; /* The unique-within-a-method safe point id. */
+	int op;
+	MonoSafePointReason reason;
+	struct MonoSafePointCfgInfo *next;
+	/* Some more information will likely have to be stored from within mono_arch_output_basic_block
+	 * like the basic block and the actual location of the instruction. Otherwise liveness 
+	 * analysis of the slots might not be possible. Adding more information should be trivial
+	 * though. */
+} MonoSafePointCfgInfo;
+
+/**
+ * A list of all the MonoSafePointJitInfo structures for a particular method
+ * along with some other useful information.
+ **/
+typedef struct {
+	MonoSafePointJitInfo *safe_points [SAFE_POINT_TYPE_MAX];
+	guint32 safe_points_len [SAFE_POINT_TYPE_MAX];
+} MonoGCInfo;
+
+gchar *mono_jit_safe_point_descr (MonoSafePointJitInfo *);
+
 /*
  * The IR-level extended basic block.  
  *
@@ -1200,6 +1251,11 @@
 	int llvm_this_reg, llvm_this_offset;
 
 	GSList *try_block_holes;
+
+#ifdef MONO_GC_SAFE_POINTS
+	MonoSafePointCfgInfo *safe_points_head [SAFE_POINT_TYPE_MAX], *safe_points_tail [SAFE_POINT_TYPE_MAX];
+	guint32 safe_points_num [SAFE_POINT_TYPE_MAX];
+#endif
 } MonoCompile;
 
 typedef enum {
@@ -1790,6 +1846,17 @@
 guint8*   mono_arch_emit_load_aotconst          (guint8 *start, guint8 *code, MonoJumpInfo **ji, int tramp_type, gconstpointer target) MONO_INTERNAL;
 GSList*   mono_arch_get_cie_program             (void) MONO_INTERNAL;
 
+#ifdef MONO_GC_SAFE_POINTS
+gpointer mono_arch_emit_safe_point (gpointer ip);
+void mono_arch_clear_safe_point (gpointer ip, gpointer prev);
+void mono_arch_patch_safe_point_context (gpointer sigctx);
+/* TODO There is probably some way to do this already, figure that out. */
+MonoContext mono_arch_mono_context_from_sigctx (gpointer sigctx);
+typedef void (*ExceptionCallbackFunc) (gpointer sigctx);
+/* Call with NULL to reset */
+void mono_arch_install_exception_callback (ExceptionCallbackFunc);
+#endif
+
 /* Soft Debug support */
 #ifdef MONO_ARCH_SOFT_DEBUG_SUPPORTED
 void      mono_arch_set_breakpoint              (MonoJitInfo *ji, guint8 *ip) MONO_INTERNAL;
@@ -2200,4 +2267,39 @@
 	MONO_AOT_WRAPPER_LAST
 };
 
+#ifdef MONO_GC_SAFE_POINTS
+
+gboolean mono_is_safe_point (const MonoInst *inst, const MonoCompile *cfg, const guint8 *code, MonoSafePointReason *reason);
+
+#define STORE_SAFE_POINT_INFO(cfg,code,reas,opcode) do {\
+	if ((cfg)->compile_aot) \
+		NOT_IMPLEMENTED; \
+	if (((cfg)->safe_points_head [reas]) == NULL) { \
+		((cfg)->safe_points_head [reas]) = ((cfg)->safe_points_tail [reas]) = mono_mempool_alloc ((cfg)->mempool, sizeof (MonoSafePointCfgInfo)); \
+	} else { \
+		((cfg)->safe_points_tail [reas])->next = mono_mempool_alloc ((cfg)->mempool, sizeof (MonoSafePointCfgInfo)); \
+		((cfg)->safe_points_tail [reas]) = ((cfg)->safe_points_tail [reas])->next; \
+	} \
+	((cfg)->safe_points_tail [reas])->native_offset = code - cfg->native_code; \
+	((cfg)->safe_points_tail [reas])->reason = reas; \
+	((cfg)->safe_points_tail [reas])->op = opcode; \
+	((cfg)->safe_points_num [reas])++; \
+} while (0)
+
+// TODO Remove reason field, not needed.
+
+#define STORE_SAFE_POINT_INFO_FULL(cfg, code, inst) \
+do { \
+	MonoSafePointReason r; \
+	if (mono_is_safe_point (inst, cfg, code, &r)) \
+		STORE_SAFE_POINT_INFO(cfg,code,r,inst->opcode); \
+} while (0)
+
+#else
+
+#define STORE_SAFE_POINT_INFO(cfg,offet,reas,oper)
+#define STORE_SAFE_POINT_INFO_FULL(cfg, code, inst)
+
+#endif
+
 #endif /* __MONO_MINI_H__ */
Index: mono/mini/mini-amd64.c
===================================================================
--- mono/mini/mini-amd64.c	(revision 159364)
+++ mono/mini/mini-amd64.c	(working copy)
@@ -2653,6 +2653,8 @@
 			no_patch = TRUE;
 		}
 
+		STORE_SAFE_POINT_INFO (cfg, code, SAFE_POINT_TYPE_METHOD_CALL, 0);
+
 		if (near_call) {
 			/* 
 			 * Align the call displacement to an address divisible by 4 so it does
@@ -3996,6 +3998,7 @@
 		case OP_LBGT_UN:
 		case OP_LBGE_UN:
 		case OP_LBLE_UN:
+			STORE_SAFE_POINT_INFO_FULL (cfg, code, ins);
 			EMIT_COND_BRANCH (ins, cc_table [mono_opcode_to_cond (ins->opcode)], cc_signed_table [mono_opcode_to_cond (ins->opcode)]);
 			break;
 
@@ -4104,6 +4107,9 @@
 				amd64_mov_reg_membase (code, AMD64_R11, AMD64_RIP, 0, 8);
 			else
 				amd64_set_reg_template (code, AMD64_R11);
+
+			STORE_SAFE_POINT_INFO (cfg, code, SAFE_POINT_TYPE_BACKWARD_BRANCH, ins->opcode);
+
 			amd64_jump_reg (code, AMD64_R11);
 			break;
 		}
@@ -4196,6 +4202,8 @@
 					amd64_mov_reg_imm (code, AMD64_RAX, nregs);
 			}
 
+			STORE_SAFE_POINT_INFO (cfg, code, SAFE_POINT_TYPE_METHOD_CALL, ins->opcode);
+
 			amd64_call_reg (code, ins->sreg1);
 			if (call->stack_usage && !CALLCONV_IS_STDCALL (call->signature->call_convention) && !cfg->arch.no_pushes)
 				amd64_alu_reg_imm (code, X86_ADD, AMD64_RSP, call->stack_usage);
@@ -4225,6 +4233,8 @@
 			amd64_nop (code);
 			amd64_nop (code);
 
+			STORE_SAFE_POINT_INFO (cfg, code, SAFE_POINT_TYPE_METHOD_CALL, ins->opcode);
+
 			amd64_call_membase (code, ins->sreg1, ins->inst_offset);
 			if (call->stack_usage && !CALLCONV_IS_STDCALL (call->signature->call_convention) && !cfg->arch.no_pushes)
 				amd64_alu_reg_imm (code, X86_ADD, AMD64_RSP, call->stack_usage);
@@ -4248,6 +4258,8 @@
 			for (i = 0; i < PARAM_REGS; ++i)
 				amd64_mov_reg_membase (code, param_regs [i], AMD64_R11, i * sizeof (gpointer), 8);
 			
+			STORE_SAFE_POINT_INFO (cfg, code, SAFE_POINT_TYPE_METHOD_CALL, ins->opcode);
+
 			/* Make the call */
 			amd64_call_reg (code, AMD64_R10);
 
@@ -4358,6 +4370,7 @@
 			/* Align stack */
 			amd64_alu_reg_imm (code, X86_SUB, AMD64_RSP, 8);
 			mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_BB, ins->inst_target_bb);
+			STORE_SAFE_POINT_INFO (cfg, code, SAFE_POINT_TYPE_METHOD_CALL, ins->opcode);
 			amd64_call_imm (code, 0);
 			mono_cfg_add_try_hole (cfg, ins->inst_eh_block, code, bb);
 			/* Restore stack alignment */
@@ -4377,6 +4390,7 @@
 		case OP_ENDFINALLY: {
 			MonoInst *spvar = mono_find_spvar_for_region (cfg, bb->region);
 			amd64_mov_reg_membase (code, AMD64_RSP, spvar->inst_basereg, spvar->inst_offset, 8);
+			STORE_SAFE_POINT_INFO (cfg, code, SAFE_POINT_TYPE_RETURN, 0);
 			amd64_ret (code);
 			break;
 		}
@@ -4384,6 +4398,7 @@
 			MonoInst *spvar = mono_find_spvar_for_region (cfg, bb->region);
 			amd64_mov_reg_membase (code, AMD64_RSP, spvar->inst_basereg, spvar->inst_offset, 8);
 			/* The local allocator will put the result into RAX */
+			STORE_SAFE_POINT_INFO (cfg, code, SAFE_POINT_TYPE_RETURN, 0);
 			amd64_ret (code);
 			break;
 		}
@@ -4396,6 +4411,7 @@
 			//if ((ins->inst_target_bb == bb->next_bb) && ins == bb->last_ins)
 			//break;
 				if (ins->inst_target_bb->native_offset) {
+					STORE_SAFE_POINT_INFO_FULL (cfg, code, ins);
 					amd64_jump_code (code, cfg->native_code + ins->inst_target_bb->native_offset); 
 				} else {
 					mono_add_patch_info (cfg, offset, MONO_PATCH_INFO_BB, ins->inst_target_bb);
@@ -4407,6 +4423,7 @@
 			}
 			break;
 		case OP_BR_REG:
+			STORE_SAFE_POINT_INFO (cfg, code, SAFE_POINT_TYPE_BACKWARD_BRANCH, ins->opcode);
 			amd64_jump_reg (code, ins->sreg1);
 			break;
 		case OP_CEQ:
@@ -4782,6 +4799,7 @@
 		case OP_FBEQ: {
 			guchar *jump = code;
 			x86_branch8 (code, X86_CC_P, 0, TRUE);
+			STORE_SAFE_POINT_INFO_FULL (cfg, code, ins);
 			EMIT_COND_BRANCH (ins, X86_CC_EQ, FALSE);
 			amd64_patch (jump, code);
 			break;
@@ -4789,17 +4807,31 @@
 		case OP_FBNE_UN:
 			/* Branch if C013 != 100 */
 			/* branch if !ZF or (PF|CF) */
+
+			/* will have the same GC map. */
+			STORE_SAFE_POINT_INFO_FULL (cfg, code, ins);
 			EMIT_COND_BRANCH (ins, X86_CC_NE, FALSE);
+
+			STORE_SAFE_POINT_INFO_FULL (cfg, code, ins);
 			EMIT_COND_BRANCH (ins, X86_CC_P, FALSE);
+
+			STORE_SAFE_POINT_INFO_FULL (cfg, code, ins);
 			EMIT_COND_BRANCH (ins, X86_CC_B, FALSE);
+
 			break;
 		case OP_FBLT:
+			STORE_SAFE_POINT_INFO_FULL (cfg, code, ins);
 			EMIT_COND_BRANCH (ins, X86_CC_GT, FALSE);
 			break;
 		case OP_FBLT_UN:
+
+			STORE_SAFE_POINT_INFO_FULL (cfg, code, ins);
 			EMIT_COND_BRANCH (ins, X86_CC_P, FALSE);
+
+			STORE_SAFE_POINT_INFO_FULL (cfg, code, ins);
 			EMIT_COND_BRANCH (ins, X86_CC_GT, FALSE);
 			break;
+
 		case OP_FBGT:
 		case OP_FBGT_UN:
 			if (ins->opcode == OP_FBGT) {
@@ -4807,12 +4839,15 @@
 
 				/* skip branch if C1=1 */
 				br1 = code;
+				STORE_SAFE_POINT_INFO_FULL (cfg, code, ins);
 				x86_branch8 (code, X86_CC_P, 0, FALSE);
 				/* branch if (C0 | C3) = 1 */
+				STORE_SAFE_POINT_INFO_FULL (cfg, code, ins);
 				EMIT_COND_BRANCH (ins, X86_CC_LT, FALSE);
 				amd64_patch (br1, code);
 				break;
 			} else {
+				STORE_SAFE_POINT_INFO_FULL (cfg, code, ins);
 				EMIT_COND_BRANCH (ins, X86_CC_LT, FALSE);
 			}
 			break;
@@ -4822,14 +4857,17 @@
 
 			/* skip branch if C1=1 */
 			br1 = code;
+			STORE_SAFE_POINT_INFO_FULL (cfg, code, ins);
 			x86_branch8 (code, X86_CC_P, 0, FALSE);
 			/* branch if (C0 | C3) = 1 */
+			STORE_SAFE_POINT_INFO_FULL (cfg, code, ins);
 			EMIT_COND_BRANCH (ins, X86_CC_BE, FALSE);
 			amd64_patch (br1, code);
 			break;
 		}
 		case OP_FBGE_UN:
 			/* Branch if C013 == 000 */
+			STORE_SAFE_POINT_INFO_FULL (cfg, code, ins);
 			EMIT_COND_BRANCH (ins, X86_CC_LE, FALSE);
 			break;
 		case OP_FBLE: {
@@ -4838,15 +4876,20 @@
 
 			/* skip branch if C1=1 */
 			br1 = code;
+			STORE_SAFE_POINT_INFO_FULL (cfg, code, ins);
 			x86_branch8 (code, X86_CC_P, 0, FALSE);
 			/* branch if C0=0 */
+			STORE_SAFE_POINT_INFO_FULL (cfg, code, ins);
 			EMIT_COND_BRANCH (ins, X86_CC_NB, FALSE);
 			amd64_patch (br1, code);
 			break;
 		}
 		case OP_FBLE_UN:
 			/* Branch if C013 != 001 */
+			STORE_SAFE_POINT_INFO_FULL (cfg, code, ins);
 			EMIT_COND_BRANCH (ins, X86_CC_P, FALSE);
+
+			STORE_SAFE_POINT_INFO_FULL (cfg, code, ins);
 			EMIT_COND_BRANCH (ins, X86_CC_GE, FALSE);
 			break;
 		case OP_CKFINITE:
@@ -6470,6 +6513,8 @@
 		amd64_leave (code);
 	}
 	async_exc_point (code);
+
+	STORE_SAFE_POINT_INFO (cfg, code, SAFE_POINT_TYPE_RETURN, 0);
 	amd64_ret (code);
 
 	cfg->code_len = code - cfg->native_code;
@@ -7718,3 +7763,63 @@
 }
 
 #endif
+
+#ifdef MONO_GC_SAFE_POINTS
+
+gpointer
+mono_arch_emit_safe_point (gpointer ip)
+{
+	guint8 old = *(guint8 *) ip;
+	guint8 *code = ip;
+
+
+	DEBUG_SAFE_POINTS ("Patching IP %p, old instruction 0x%x\n", ip, *code);
+
+	x86_int_trap (code);
+
+	/* No need to allocate memory and return a pointer when
+	 * sizeof (old) < sizeof (gpointer). The compiler gives
+	 * a warning though. */
+
+	return (gpointer) old;
+}
+
+void
+mono_arch_clear_safe_point (gpointer ip, gpointer prev)
+{
+	if (((guint8) prev) == INT_TRAP_INSTRUCTION_BYTE)
+		return;
+	DEBUG_SAFE_POINTS ("Clearing IP %p, previous instruction 0x%x\n", ip, (guint8) prev);
+	*(guint8 *) ip = (guint8) prev;
+}
+
+MonoContext
+mono_arch_mono_context_from_sigctx (gpointer sigctx)
+{
+	MonoContext ctx;
+
+	ctx.rax = UCONTEXT_GREGS (sigctx) [REG_RAX];
+	ctx.rbx = UCONTEXT_GREGS (sigctx) [REG_RBX];
+	ctx.rcx = UCONTEXT_GREGS (sigctx) [REG_RCX];
+	ctx.rdx = UCONTEXT_GREGS (sigctx) [REG_RDX];
+	ctx.rbp = UCONTEXT_GREGS (sigctx) [REG_RBP];
+	ctx.rsp = UCONTEXT_GREGS (sigctx) [REG_RSP];
+	ctx.rsi = UCONTEXT_GREGS (sigctx) [REG_RSI];
+	ctx.rdi = UCONTEXT_GREGS (sigctx) [REG_RDI];
+	ctx.rip = UCONTEXT_GREGS (sigctx) [REG_RIP];
+	ctx.r12 = UCONTEXT_GREGS (sigctx) [REG_R12];
+	ctx.r13 = UCONTEXT_GREGS (sigctx) [REG_R13];
+	ctx.r14 = UCONTEXT_GREGS (sigctx) [REG_R14];
+	ctx.r15 = UCONTEXT_GREGS (sigctx) [REG_R15];
+
+	return ctx;
+}
+
+void
+mono_arch_patch_safe_point_context (gpointer sigctx)
+{
+	UCONTEXT_GREGS (sigctx) [REG_RIP] = UCONTEXT_GREGS (sigctx) [REG_RIP] - 1;
+}
+
+#endif
+
Index: mono/mini/exceptions-amd64.c
===================================================================
--- mono/mini/exceptions-amd64.c	(revision 159364)
+++ mono/mini/exceptions-amd64.c	(working copy)
@@ -285,6 +285,24 @@
 	return start;
 }
 
+#ifdef MONO_GC_SAFE_POINTS
+
+static ExceptionCallbackFunc gc_exception_callback = NULL;
+
+void
+mono_arch_install_exception_callback (ExceptionCallbackFunc cb)
+{
+	if (cb && gc_exception_callback)
+		g_warning ("Overwriting existing exception callback in mono_arch_install_exception_callback");
+	if (!cb && !gc_exception_callback)
+		g_warning ("Clearing NULL exception callback in mono_arch_install_exception_callback");
+
+	DEBUG_SAFE_POINTS ("Adding exception sgen hook.\n");
+	gc_exception_callback = cb;
+}
+
+#endif
+
 /* 
  * The first few arguments are dummy, to force the other arguments to be passed on
  * the stack, this avoids overwriting the argument registers in the throw trampoline.
@@ -300,6 +318,33 @@
 
 	if (!restore_context)
 		restore_context = mono_get_restore_context ();
+	
+#ifdef MONO_GC_SAFE_POINTS
+	if (gc_exception_callback) {
+		ucontext_t ctx;
+		#define COPY_REG(r) UCONTEXT_GREGS (&ctx) [REG_R ## r] = regs [AMD64_R ## r]
+		COPY_REG (AX);
+		COPY_REG (BX);
+		COPY_REG (CX);
+		COPY_REG (DX);
+		COPY_REG (SI);
+		COPY_REG (DI);
+		COPY_REG (BP);
+		COPY_REG (8);
+		COPY_REG (9);
+		COPY_REG (10);
+		COPY_REG (11);
+		COPY_REG (12);
+		COPY_REG (13);
+		COPY_REG (14);
+		COPY_REG (15);
+		#undef COPY_REG
+		DEBUG_SAFE_POINTS ("Exception thrown, halting thread.");
+		gc_exception_callback (&ctx);
+	}
+	/* Execution resumes here to regular exception handling code, once
+	 * the collection is over. */
+#endif
 
 	ctx.rsp = regs [AMD64_RSP];
 	ctx.rip = rip;
Index: mono/mini/mini-gc.c
===================================================================
--- mono/mini/mini-gc.c	(revision 159364)
+++ mono/mini/mini-gc.c	(working copy)
@@ -3,606 +3,321 @@
  *
  * Author:
  *   Zoltan Varga (vargaz@gmail.com)
+ *   Sanjoy Das (sanjoy@playingwithpointers.com)
  *
  * Copyright 2009 Novell, Inc (http://www.novell.com)
  */
 
 #include "config.h"
 #include "mini-gc.h"
+#include "mini.h"
 
-#if 0
-//#ifdef HAVE_SGEN_GC
-
 #include <mono/metadata/gc-internal.h>
-#include <mono/utils/mono-counters.h>
+#include <mono/metadata/sgen-archdep.h>
 
-#define ALIGN_TO(val,align) ((((guint64)val) + ((align) - 1)) & ~((align) - 1))
-
-#if 1
-#define DEBUG(s) do { s; } while (0)
-#else
-#define DEBUG(s)
+#ifdef HAVE_SGEN_GC
+#include <mono/metadata/sgen-gc.h>
 #endif
 
-#if 1
-#define DEBUG_GC_MAP(s) do { s; fflush (stdout); } while (0)
-#else
-#define DEBUG_GC_MAP(s)
-#endif
+#ifdef MONO_GC_SAFE_POINTS
 
-#define GC_BITS_PER_WORD (sizeof (gsize) * 8)
+//#define REPORT_SAFE_POINT_STATISTICS
 
-/*
- * Per-thread data kept by this module. This is stored in the GC and passed to us as
- * parameters, instead of being stored in a TLS variable, since during a collection,
- * only the collection thread is active.
- */
+typedef struct StackFrameMap {
+//	GCStackMap *map;
+	struct StackFrameMap *next;
+} StackFrameMap;
+
 typedef struct {
-	MonoLMF *lmf;
-	MonoContext ctx;
-	gboolean has_context;
-	MonoJitTlsData *jit_tls;
-} TlsData;
+	/* Contains the maps for the stack frames of the methods currently on this thread's stack. */
+	StackFrameMap *root;
 
-typedef enum {
-	/* Stack slot doesn't contain a reference */
-	SLOT_NOREF = 0,
-	/* Stack slot contains a reference */
-	SLOT_REF = 1,
-	/* No info, slot needs to be scanned conservatively */
-	SLOT_PIN = 2
-} StackSlotType;
+	/* The IP of the safe point where this thread is parked at. Only valid if
+	 * thread_state == THREAD_PARKED_FORCED */
+	GPtrArray *safe_point_ips;
 
-/* 
- * Contains information needed to mark a stack frame.
- * FIXME: Optimize the memory usage.
- */
-typedef struct {
-	/* The frame pointer register */
-	int frame_reg;
-	/* The offset of the local variable area in the stack frame relative to the frame pointer */
-	int locals_offset;
-	/* The size of the locals area. Can't use nslots as it includes padding */
-	int locals_size;
-	/* The number of stack slots */
-	int nslots;
-	/* 
-	 * The gc map itself.
-	 */
-	StackSlotType *slots;
-	/* A pair of low pc offset-high pc offset for each SLOT_REF value in gc_refs */
-	guint32 live_ranges [MONO_ZERO_LEN_ARRAY];
-} GCMap;
+	/* The previous code that the safe point location had. This needs to be 
+	 * restored before resuming the thread. */
+	GPtrArray *previous_instructions; 
 
-/* Statistics */
-static guint32 gc_maps_size;
+	/* The context of the method before the SIGSEGV. This slightly modified and restored
+	 * to resume a thread. */
+	gpointer previous_sigctx;
 
+	int thread_state;
+
+	/* The number of levels down the stack the safe point has been inserted. Not needed currently
+	 * since the SIGTRAP handler directly gets the context. Plus stack traversing without frame
+	 * pointers is not trivial anyways. */
+	int level;
+
+#ifdef REPORT_SAFE_POINT_STATISTICS
+	int threads_stopped, threads_stopped_at_safe_points;
+#endif
+
+} TlsJitInfo;
+
+enum {
+	THREAD_RUNNING,
+	THREAD_PARKED_AT_SAFE_POINT,
+	THREAD_PARKED_FORCED
+};
+
 static gpointer
 thread_attach_func (void)
 {
-	return g_new0 (TlsData, 1);
+	return g_malloc0 (sizeof (TlsJitInfo));
 }
 
-static void
-thread_suspend_func (gpointer user_data, void *sigctx)
-{
-	TlsData *tls = user_data;
+typedef gboolean (*ForEachStackFrameFunc) (MonoJitInfo * /* Jit info */, MonoContext *, int /* counter */, gpointer /* user_data */);
 
-	tls->lmf = mono_get_lmf ();
-	if (sigctx) {
-		mono_arch_sigctx_to_monoctx (sigctx, &tls->ctx);
-		tls->has_context = TRUE;
-	} else {
-		tls->has_context = FALSE;
-	}
-	tls->jit_tls = TlsGetValue (mono_jit_tls_id);
-}
-
-static int precise_frame_count [2], precise_frame_limit = -1;
-static gboolean precise_frame_limit_inited;
-
-#define DEAD_REF ((gpointer)(gssize)0x2a2a2a2a2a2a2a2aULL)
-
 static void
-thread_mark_func (gpointer user_data, guint8 *stack_start, guint8 *stack_end, gboolean precise)
+for_each_stack_frame (gpointer sigctx, ForEachStackFrameFunc func, gpointer user_data)
 {
-	TlsData *tls = user_data;
-	MonoJitInfo *ji, res;
+	MonoDomain *domain = mono_domain_get ();
+	MonoJitTlsData *jit_tls = TlsGetValue (mono_get_jit_tls_key ());
+	MonoLMF *lmf = mono_get_lmf ();
+	MonoJitInfo *ji, rji;
 	MonoContext ctx, new_ctx;
-	MonoLMF *lmf = tls->lmf;
-	guint8 *stack_limit;
-	gboolean last = TRUE, managed;
-	GCMap *map;
-	guint8* fp, *locals_start, *locals_end;
-	int i, pc_offset;
-	int scanned = 0, scanned_precisely, scanned_conservatively;
+	int counter = 0;
+	MonoMethod *last_method = NULL;
 
-	if (mono_thread_internal_current () == NULL) {
-		if (!precise)
-			mono_gc_conservatively_scan_area (stack_start, stack_end);			
-		return;
-	}
+	ctx = mono_arch_mono_context_from_sigctx (sigctx);
 
-	/* Number of bytes scanned based on GC map data */
-	scanned = 0;
-	/* Number of bytes scanned precisely based on GC map data */
-	scanned_precisely = 0;
-	/* Number of bytes scanned conservatively based on GC map data */
-	scanned_conservatively = 0;
+	g_assert (MONO_CONTEXT_GET_IP (&ctx) == ARCH_SIGCTX_IP (sigctx));
 
-	/* FIXME: sgen-gc.c calls this multiple times for each major collection from pin_from_roots */
+	if (mono_thread_internal_current () == NULL)
+		return;
 
-	/* FIXME: Use real gc descriptors instead of bitmaps */
+	while (1) {
 
-	/* This is one past the last address which we have scanned */
-	stack_limit = stack_start;
+		ji = mono_find_jit_info (domain, jit_tls, &rji, NULL, &ctx, &new_ctx, NULL, &lmf, NULL, NULL);
 
-	DEBUG (printf ("*** %s stack marking %p-%p ***\n", precise ? "Precise" : "Conservative", stack_start, stack_end));
+		if (!ji || ji == (gpointer)-1 || MONO_CONTEXT_GET_SP (&ctx) >= jit_tls->end_of_stack)
+			break; 
+		
+		/* See mini-exceptions.c : ves_icall_get_frame_info for an explanation */
+		if (ji->method->wrapper_type == MONO_WRAPPER_MANAGED_TO_NATIVE && ji->method == last_method)
+			continue;
 
-	if (!tls->has_context) {
-		memset (&new_ctx, 0, sizeof (ctx));
+		last_method = ji->method;
 
-		while (TRUE) {
-			memcpy (&ctx, &new_ctx, sizeof (ctx));
+		if (!func (ji, &ctx, counter, user_data))
+			break;
 
-			g_assert ((guint64)stack_limit % sizeof (gpointer) == 0);
+		ctx = new_ctx;
+		counter++;
+	}
+}
 
-			// FIXME: This doesn't work with appdomain transitions
-			ji = mono_find_jit_info (mono_domain_get (), tls->jit_tls, &res, NULL,
-									 &ctx, &new_ctx, NULL, &lmf, NULL, &managed);
-			if (ji == (gpointer)-1)
-				break;
+static void
+thread_suspend_func (gpointer tls_data_prev, gpointer context)
+{
+}
 
-			/* The last frame can be in any state so mark conservatively */
-			if (last) {
-				last = FALSE;
-				continue;
-			}
+typedef struct {
+	GPtrArray *ips;
+	int level;
+} SafePointIPData;
 
-			/* These frames are returned by mono_find_jit_info () two times */
-			if (!managed)
-				continue;
+static gboolean
+iterate_find_safe_point_ip (MonoJitInfo *ji, MonoContext *ctx, int counter, gpointer user_data)
+{
+	SafePointIPData *ip_data = user_data;
+	MonoGCInfo *gc_info = ji->gc_info;
+	gpointer native_ip = MONO_CONTEXT_GET_IP (ctx);
+	int i;
 
-			/* Scan the frame of this method */
+	if (native_ip < ji->code_start)
+		return TRUE;
 
-			/*
-			 * A frame contains the following:
-			 * - saved registers
-			 * - saved args
-			 * - locals
-			 * - spill area
-			 * - localloc-ed memory
-			 * Currently, only the locals are scanned precisely.
-			 */
+	ip_data->ips = g_ptr_array_new ();
 
-			map = ji->gc_info;
+	/* At least one return statement must exist, basic sanity check. */
+	g_assert (gc_info->safe_points_len [SAFE_POINT_TYPE_RETURN]);
 
-			if (!map) {
-				DEBUG (char *fname = mono_method_full_name (ji->method, TRUE); printf ("Mark(%d): No GC map for %s\n", precise, fname); g_free (fname));
-				continue;
-			}
+	DEBUG_SAFE_POINTS ("%p / %s, offset = 0x%x, ip = %p\n", (gpointer) pthread_self (), mono_method_full_name (ji->method, TRUE), native_ip - ji->code_start, native_ip);
 
-			/*
-			 * Debugging aid to control the number of frames scanned precisely
-			 */
-			if (!precise_frame_limit_inited) {
-				if (getenv ("MONO_PRECISE_COUNT"))
-					precise_frame_limit = atoi (getenv ("MONO_PRECISE_COUNT"));
-				precise_frame_limit_inited = TRUE;
-			}
-				
-			if (precise_frame_limit != -1) {
-				if (precise_frame_count [precise] == precise_frame_limit)
-					printf ("LAST PRECISE FRAME: %s\n", mono_method_full_name (ji->method, TRUE));
-				if (precise_frame_count [precise] > precise_frame_limit)
-					continue;
-			}
-			precise_frame_count [precise] ++;
+	for (i = 0; i < gc_info->safe_points_len [SAFE_POINT_TYPE_RETURN]; i++) {
+		g_ptr_array_add (ip_data->ips, (gpointer) (gc_info->safe_points [SAFE_POINT_TYPE_RETURN] [i].native_offset + ji->code_start));
+		DEBUG_SAFE_POINTS ("%s ", mono_jit_safe_point_descr (&(gc_info->safe_points [SAFE_POINT_TYPE_RETURN] [i])));
+	}
 
-#ifdef __x86_64__
-			if (map->frame_reg == AMD64_RSP)
-				fp = (guint8*)ctx.rsp;
-			else if (map->frame_reg == AMD64_RBP)
-				fp = (guint8*)ctx.rbp;
-			else
-				g_assert_not_reached ();
-#else
-			fp = NULL;
-			g_assert_not_reached ();
-#endif
+	DEBUG_SAFE_POINTS ("| ");
 
-			locals_start = fp + map->locals_offset;
-			locals_end = locals_start + map->locals_size;
+	/* Checking mono_sgen_is_inconsistent_method is better than imposing some arbitrary restriction
+	 * on managed allocators and write barriers. */
 
-			pc_offset = (guint8*)MONO_CONTEXT_GET_IP (&ctx) - (guint8*)ji->code_start;
-			g_assert (pc_offset >= 0);
+	for (i = 0; i < gc_info->safe_points_len [SAFE_POINT_TYPE_BACKWARD_BRANCH] && !mono_sgen_is_inconsistent_method (ji->method); i++) {
+		if ((gc_info->safe_points [SAFE_POINT_TYPE_BACKWARD_BRANCH] [i].native_offset + ji->code_start) >= native_ip) {
+			g_ptr_array_add (ip_data->ips, (gpointer) (gc_info->safe_points [SAFE_POINT_TYPE_BACKWARD_BRANCH] [i].native_offset + ji->code_start));
+			DEBUG_SAFE_POINTS ("%s ", mono_jit_safe_point_descr (&(gc_info->safe_points [SAFE_POINT_TYPE_BACKWARD_BRANCH] [i])));
+		}
+	}
 
-			DEBUG (char *fname = mono_method_full_name (ji->method, TRUE); printf ("Mark(%d): %s+0x%x (%p) limit=%p fp=%p locals=%p-%p (%d)\n", precise, fname, pc_offset, (gpointer)MONO_CONTEXT_GET_IP (&ctx), stack_limit, fp, locals_start, locals_end, (int)(locals_end - locals_start)); g_free (fname));
+	DEBUG_SAFE_POINTS ("| ");
 
-			/* 
-			 * FIXME: Add a function to mark using a bitmap, to avoid doing a 
-			 * call for each object.
-			 */
+	for (i = 0; i < gc_info->safe_points_len [SAFE_POINT_TYPE_METHOD_CALL]; i++) {
+		if ((gc_info->safe_points [SAFE_POINT_TYPE_METHOD_CALL] [i].native_offset + ji->code_start) >= native_ip) {
+			g_ptr_array_add (ip_data->ips, (gpointer) (gc_info->safe_points [SAFE_POINT_TYPE_METHOD_CALL] [i].native_offset + ji->code_start));
+			DEBUG_SAFE_POINTS ("%s ", mono_jit_safe_point_descr (&(gc_info->safe_points [SAFE_POINT_TYPE_METHOD_CALL] [i])));
+		}
+	}
 
-			scanned += locals_end - locals_start;
+	DEBUG_SAFE_POINTS ("\n");
 
-			/* Pinning needs to be done first, then the precise scan later */
+	return FALSE;
+}
 
-			if (!precise) {
-				g_assert (locals_start >= stack_limit);
+static gboolean
+thread_prepare_park_func (gpointer user_data, gpointer context)
+{
+	SafePointIPData ip_data = {0};
+	MonoDomain *domain = mono_domain_get ();
+	TlsJitInfo *tls = user_data;
+	int i;
+	tls->thread_state = THREAD_RUNNING;
 
-				if (locals_start > stack_limit) {
-					/* This scans the previously skipped frames as well */
-					DEBUG (printf ("\tscan area %p-%p.\n", stack_limit, locals_start));
-					mono_gc_conservatively_scan_area (stack_limit, locals_start);
-				}
+#ifdef REPORT_SAFE_POINT_STATISTICS
+	tls->threads_stopped++;
+#endif
 
-				if (map->slots) {
-					guint8 *p;
+	if (!mono_jit_info_table_find (domain, ARCH_SIGCTX_IP (context))) {
+		tls->thread_state = THREAD_PARKED_FORCED;
+		return TRUE;
+	}
 
-					p = locals_start;
-					for (i = 0; i < map->nslots; ++i) {
-						if (map->slots [i] == SLOT_PIN) {
-							DEBUG (printf ("\tscan slot %s0x%x(fp)=%p.\n", (guint8*)p > (guint8*)fp ? "" : "-", ABS ((int)((gssize)p - (gssize)fp)), p));
-							mono_gc_conservatively_scan_area (p, p + sizeof (gpointer));
-							scanned_conservatively += sizeof (gpointer);
-						}
-						p += sizeof (gpointer);
-					}
-				}
+	for_each_stack_frame (context, iterate_find_safe_point_ip, &ip_data);
 
-				stack_limit = locals_end;
-			} else {
-				if (map->slots) {
-					int loffset = 0;
+	g_assert (ip_data.ips);
 
-					for (i = 0; i < map->nslots; ++i) {
-						if (map->slots [i] == SLOT_REF) {
-							MonoObject **ptr = (MonoObject**)(locals_start + (i * sizeof (gpointer)));
-							MonoObject *obj = *ptr;
+	tls->safe_point_ips = ip_data.ips;
+	tls->previous_instructions = g_ptr_array_new ();
 
-							if (pc_offset >= map->live_ranges [loffset] && pc_offset < map->live_ranges [loffset + 1] && obj != DEAD_REF) {
-								if (obj) {
-									DEBUG (printf ("\tref %s0x%x(fp)=%p: %p ->", (guint8*)ptr >= (guint8*)fp ? "" : "-", ABS ((int)((gssize)ptr - (gssize)fp)), ptr, obj));
-									*ptr = mono_gc_scan_object (obj);
-									DEBUG (printf (" %p.\n", *ptr));
-								} else {
-									DEBUG (printf ("\tref %s0x%x(fp)=%p: %p.\n", (guint8*)ptr >= (guint8*)fp ? "" : "-", ABS ((int)((gssize)ptr - (gssize)fp)), ptr, obj));
-								}
-							} else {
-								DEBUG (printf ("\tref %s0x%x(fp)=%p: dead (%p)\n", (guint8*)ptr >= (guint8*)fp ? "" : "-", ABS ((int)((gssize)ptr - (gssize)fp)), ptr, obj));
-								/*
-								 * This serves two purposes:
-								 * - fail fast if the live range is incorrect, and
-								 * the JITted code tries to access this object
-								 * - it avoids problems when a dead slot becomes live
-								 * again due to a backward branch 
-								 * (see test_0_liveness_6).
-								 */
-								*ptr = DEAD_REF;
-							}
+	DEBUG_SAFE_POINTS ("Patching %d instructions.\n", ip_data.ips->len);
 
-							loffset += 2;
-							scanned_precisely += sizeof (gpointer);
-						} else if (map->slots [i] == SLOT_NOREF) {
-							scanned_precisely += sizeof (gpointer);
-						}
-					}
-				}
-			}
-		}
-
-		if (stack_limit < stack_end && !precise) {
-			DEBUG (printf ("\tscan area %p-%p.\n", stack_limit, stack_end));
-			mono_gc_conservatively_scan_area (stack_limit, stack_end);
-		}
-	} else {
-		// FIXME:
-		if (!precise) {
-			DEBUG (printf ("\tno context, scan area %p-%p.\n", stack_start, stack_end));
-			mono_gc_conservatively_scan_area (stack_start, stack_end);
-		}
+	for (i = 0; i < ip_data.ips->len; i++) {
+		g_ptr_array_add (tls->previous_instructions,
+				mono_arch_emit_safe_point (g_ptr_array_index (ip_data.ips, i)));
 	}
 
-	DEBUG (printf ("Marked %d bytes, p=%d,c=%d out of %d.\n", scanned, scanned_precisely, scanned_conservatively, (int)(stack_end - stack_start)));
+	tls->thread_state = THREAD_PARKED_AT_SAFE_POINT;
+	tls->previous_sigctx = context;
+#ifdef REPORT_SAFE_POINT_STATISTICS
+	tls->threads_stopped_at_safe_points++;
+#endif
+	DEBUG_SAFE_POINTS ("Patched thread %p.\n", (gpointer) pthread_self ());
 
-	//mono_gc_conservatively_scan_area (stack_start, stack_end);
+	return FALSE;
 }
 
-#define set_slot(slots, nslots, pos, val) do {	\
-		g_assert ((pos) < (nslots));		   \
-		(slots) [(pos)] = (val);			   \
-	} while (0)
-
-void
-mini_gc_init_gc_map (MonoCompile *cfg)
+static void
+thread_resume_prepare_func (gpointer user_data)
 {
-	if (COMPILE_LLVM (cfg))
-		return;
+	TlsJitInfo *tls = user_data;
 
-	/* See mini_gc_create_gc_map () for comments as to why these are needed */
-
-	/* Extend the live ranges using the liveness information */
-	cfg->compute_precise_live_ranges = TRUE;
-	/* Is this still needed ? */
-	cfg->disable_reuse_ref_stack_slots = TRUE;
-	/* 
-	 * Initialize all variables holding refs to null in the initlocals bblock, not just
-	 *  variables representing IL locals.
-	 */
-	cfg->init_ref_vars = TRUE;
-	/* Prevent these initializations from being optimized away */
-	cfg->disable_initlocals_opt_refs = TRUE;
-}
-
-void
-mini_gc_create_gc_map (MonoCompile *cfg)
-{
-	GCMap *map;
-	int i, nslots, alloc_size, loffset, min_offset, max_offset;
-	StackSlotType *slots = NULL;
-	gboolean norefs = FALSE;
-	guint32 *live_range_start, *live_range_end;
-
-	/*
-	 * Since we currently don't use GC safe points, we need to create GC maps which
-	 * are precise at every instruction within a method. We use the live ranges
-	 * calculated by the JIT in mono_spill_global_vars () for this. Unfortunately by 
-	 * default these are not precise enought for several reasons:
-	 * - the current calculation of MonoMethodVar->live_range_start/end is incorrect,
-	 * it doesn't take into account loops etc. It needs to use the results of the
-	 * liveness analysis pass.
-	 * - the current liveness analysis pass is too conservative, ie. the live_in/out
-	 * sets computed by it are sometimes include too many variables, for example because
-	 * of the bogus links between bblocks. This means the live_in/out sets cannot be
-	 * used to reliably compute precise live ranges.
-	 * - stack slots are shared, which means the live ranges of stack slots have holes
-	 * in them.
-	 * - the live ranges of variables used in out-of-line bblocks also have holes in
-	 * them.
-	 * - the live ranges of variables used for handling stack args also have holes in
-	 * them:
-	 *   if (A)
-     *     x = <ref>
-	 *   else
-	 *     x = <ref>
-	 *   <use x>
-	 * Here x is not live between the first and the second assignment.
-	 *
-	 * To work around these problems, we set a few cfg flags in mini_init_gc_maps ()
-	 * which guarantee that the live range of stack slots have no holes, i.e. they hold
-	 * a valid value (or null) during their entire live range.
-	 * FIXME: This doesn't completely work yet, see test_0_liveness_6 (), where
-	 * a variable becomes dead, then alive again.
-	 */
-	//NOT_IMPLEMENTED;
-
-	if (!(cfg->comp_done & MONO_COMP_LIVENESS))
-		/* Without liveness info, the live ranges are not precise enough */
+	if (tls->thread_state == THREAD_RUNNING) {
+		g_warning ("thread_resume_prepare_func called with tls->thread_state == THREAD_RUNNING");
+		tls->previous_sigctx = NULL;
 		return;
-
-#ifdef TARGET_AMD64
-	min_offset = ALIGN_TO (cfg->locals_min_stack_offset, sizeof (gpointer));
-	max_offset = cfg->locals_max_stack_offset;
-#else
-	/* min/max stack offset needs to be computed in mono_arch_allocate_vars () */
-	NOT_IMPLEMENTED;
-#endif
-
-	for (i = cfg->locals_start; i < cfg->num_varinfo; i++) {
-		MonoInst *ins = cfg->varinfo [i];
-		MonoType *t = ins->inst_vtype;
-
-		if ((MONO_TYPE_ISSTRUCT (t) && ins->klass->has_references))
-			break;
-		if (MONO_TYPE_ISSTRUCT (t))
-			break;
-		if (t->byref || t->type == MONO_TYPE_PTR)
-			break;
-		if (ins && ins->opcode == OP_REGOFFSET && MONO_TYPE_IS_REFERENCE (ins->inst_vtype))
-			break;
 	}
 
-	if (i == cfg->num_varinfo)
-		norefs = TRUE;
-
-	if (cfg->verbose_level > 1)
-		printf ("GC Map for %s: 0x%x-0x%x\n", mono_method_full_name (cfg->method, TRUE), min_offset, max_offset);
-
-	nslots = (max_offset - min_offset) / sizeof (gpointer);
-	if (!norefs) {
-		alloc_size = nslots * sizeof (StackSlotType);
-		slots = mono_domain_alloc0 (cfg->domain, alloc_size);
-		for (i = 0; i < nslots; ++i)
-			slots [i] = SLOT_NOREF;
-		gc_maps_size += alloc_size;
+	if (tls->thread_state == THREAD_PARKED_AT_SAFE_POINT) {
+		int i;
+		for (i = 0; i < tls->safe_point_ips->len; i++) 
+			mono_arch_clear_safe_point (g_ptr_array_index (tls->safe_point_ips, i), g_ptr_array_index (tls->previous_instructions, i));
+		g_ptr_array_free (tls->safe_point_ips, TRUE);
+		g_ptr_array_free (tls->previous_instructions, TRUE);
 	}
-	live_range_start = g_new (guint32, nslots);
-	live_range_end = g_new (guint32, nslots);
-	loffset = 0;
 
-	for (i = 0; i < nslots; ++i) {
-		live_range_start [i] = (guint32)-1;
-		live_range_end [i] = 0;
-	}
+	tls->thread_state = THREAD_RUNNING;
+	tls->previous_sigctx = NULL;
+}
 
-	for (i = cfg->locals_start; i < cfg->num_varinfo; i++) {
-		MonoInst *ins = cfg->varinfo [i];
-		MonoType *t = ins->inst_vtype;
-		MonoMethodVar *vmv;
-		guint32 pos;
+static void
+thread_resume_func (gpointer user_data)
+{
+	/* Not needed now, might be needed later. */
+}
 
-		if (norefs)
-			continue;
+static void
+thread_mark_func (gpointer user_data, guint8 *stack_start, guint8 *stack_end, gboolean precise)
+{
+}
 
-		vmv = MONO_VARINFO (cfg, i);
+static void
+int_3_handler (int sig, siginfo_t *siginfo, void *context)
+{
+	mono_arch_patch_safe_point_context (context);
+	mono_sgen_thread_ready_to_suspend (context);
+}
 
-		if (ins->opcode != OP_REGOFFSET)
-			continue;
+static void
+gc_exception_callback (gpointer sigctx)
+{
+	mono_sgen_thread_ready_to_suspend (sigctx);
+}
 
-		if (ins->inst_offset % sizeof (gpointer) != 0)
-			continue;
+static struct sigaction prev_sigaction_info;
 
-		pos = (ins->inst_offset - min_offset) / sizeof (gpointer);
+static void
+thread_initiate_parking (gpointer user_data)
+{
+	struct sigaction sinfo;
 
-		if ((MONO_TYPE_ISSTRUCT (t) && !ins->klass->has_references))
-			continue;
+	sigfillset (&sinfo.sa_mask);
+	sinfo.sa_flags = SA_RESTART | SA_SIGINFO;
+	sinfo.sa_sigaction = int_3_handler;
 
-		if ((MONO_TYPE_ISSTRUCT (t) && ins->klass->has_references)) {
-			int numbits, j;
-			gsize *bitmap;
-			gboolean pin;
+	if (sigaction (SIGTRAP, &sinfo, &prev_sigaction_info) != 0)
+		g_error ("failed sigaction to set int_3_handler");
 
-			if (ins->klass->generic_container || mono_class_is_open_constructed_type (t)) {
-				/* FIXME: Generic sharing */
-				pin = TRUE;
-			} else {
-				mono_class_compute_gc_descriptor (ins->klass);
-
-				bitmap = mono_gc_get_bitmap_for_descr (ins->klass->gc_descr, &numbits);
-
-				if (bitmap) {
-					for (j = 0; j < numbits; ++j) {
-						if (bitmap [j / GC_BITS_PER_WORD] & ((gsize)1 << (j % GC_BITS_PER_WORD))) {
-							/* The descriptor is for the boxed object */
-							set_slot (slots, nslots, (pos + j - (sizeof (MonoObject) / sizeof (gpointer))), SLOT_REF);
-						}
-					}
-					g_free (bitmap);
-
-					if (cfg->verbose_level > 1)
-						printf ("\tvtype at fp+0x%x: %s -> 0x%x\n", (int)ins->inst_offset, mono_type_full_name (ins->inst_vtype), (int)ins->inst_offset);
-
-					// FIXME: These have no live range
-					pin = TRUE;
-				} else {
-					// FIXME:
-					pin = TRUE;
-				}
-			}
-
-			if (ins->backend.is_pinvoke)
-				pin = TRUE;
-
-			if (pin) {
-				int size;
-
-				if (ins->backend.is_pinvoke)
-					size = mono_class_native_size (ins->klass, NULL);
-				else
-					size = mono_class_value_size (ins->klass, NULL);
-				for (j = 0; j < size / sizeof (gpointer); ++j)
-					set_slot (slots, nslots, pos + j, SLOT_PIN);
-			}
-			continue;
-		}
-
-		if (ins->inst_offset < min_offset || ins->inst_offset >= max_offset)
-			/* Vret addr etc. */
-			continue;
-
-		if (t->byref || t->type == MONO_TYPE_PTR || t->type == MONO_TYPE_I || t->type == MONO_TYPE_U) {
-			set_slot (slots, nslots, pos, SLOT_PIN);
-			continue;
-		}
-
-		if (MONO_TYPE_IS_REFERENCE (ins->inst_vtype)) {
-			if (vmv && !vmv->live_range_start) {
-				set_slot (slots, nslots, pos, SLOT_PIN);
-				continue;
-			}
-
-			if (ins->flags & (MONO_INST_VOLATILE | MONO_INST_INDIRECT)) {
-				set_slot (slots, nslots, pos, SLOT_PIN);
-				continue;
-			}
-
-			set_slot (slots, nslots, pos, SLOT_REF);
-
-			/* Stack slots holding refs shouldn't be shared */
-			g_assert (!live_range_end [pos]);
-			live_range_start [pos] = vmv->live_range_start;
-			live_range_end [pos] = vmv->live_range_end;
-
-			if (cfg->verbose_level > 1)
-				printf ("\tref at %s0x%x(fp) (slot=%d): %s [0x%x - 0x%x]\n", ins->inst_offset < 0 ? "-" : "", (ins->inst_offset < 0) ? -(int)ins->inst_offset : (int)ins->inst_offset, pos, mono_type_full_name (ins->inst_vtype), vmv->live_range_start, vmv->live_range_end);
-		}
-	}
-
-	alloc_size = sizeof (GCMap) + (norefs ? 0 : (nslots - MONO_ZERO_LEN_ARRAY) * sizeof (guint32) * 2);
-	map = mono_domain_alloc0 (cfg->domain, alloc_size);
-	gc_maps_size += alloc_size;
-
-	map->frame_reg = cfg->frame_reg;
-	map->locals_offset = min_offset;
-	map->locals_size = ALIGN_TO (max_offset - min_offset, sizeof (gpointer));
-	map->nslots = nslots;
-	map->slots = slots;
-	loffset = 0;
-	if (!norefs) {
-		for (i = 0; i < nslots; ++i) {
-			if (map->slots [i] == SLOT_REF) {
-				map->live_ranges [loffset ++] = live_range_start [i];
-				map->live_ranges [loffset ++] = live_range_end [i];
-			}
-		}
-	}
-
-#if 1
+	mono_arch_install_exception_callback (gc_exception_callback);
+	
+#ifdef REPORT_SAFE_POINT_STATISTICS
 	{
-		static int precise_count;
-
-		if (map->slots) {
-			precise_count ++;
-			if (getenv ("MONO_GCMAP_COUNT")) {
-				if (precise_count == atoi (getenv ("MONO_GCMAP_COUNT")))
-					printf ("LAST: %s\n", mono_method_full_name (cfg->method, TRUE));
-				if (precise_count > atoi (getenv ("MONO_GCMAP_COUNT"))) {
-					for (i = 0; i < nslots; ++i)
-						map->slots [i] = SLOT_PIN;
-				}
-			}
-		}
+		TlsJitInfo *info = user_data;
+		fprintf (stderr, "%d out of %d threads parked at safe points.\n", info->threads_stopped_at_safe_points, info->threads_stopped);
+		info->threads_stopped_at_safe_points = info->threads_stopped = 0;
 	}
 #endif
+}
 
-	cfg->jit_info->gc_info = map;
+static void
+thread_dissolve_parking (gpointer user_data)
+{
+	if (sigaction (SIGTRAP, &prev_sigaction_info, NULL) != 0)
+		g_error ("failed sigaction to unset int_3_handler");
+	mono_arch_install_exception_callback (NULL);
+}
 
-	g_free (live_range_start);
-	g_free (live_range_end);
+static void
+thread_detach_function (gpointer user_data)
+{
+	g_assert (user_data);
+	g_free (user_data);
 }
 
+#endif /* MONO_GC_SAFE_POINTS */
+
 void
 mini_gc_init (void)
 {
 	MonoGCCallbacks cb;
-
 	memset (&cb, 0, sizeof (cb));
+
+#ifdef MONO_GC_SAFE_POINTS
 	cb.thread_attach_func = thread_attach_func;
 	cb.thread_suspend_func = thread_suspend_func;
-	/* Comment this out to disable precise stack marking */
 	cb.thread_mark_func = thread_mark_func;
-	mono_gc_set_gc_callbacks (&cb);
+	cb.thread_prepare_park_func = thread_prepare_park_func;
+	cb.thread_resume_prepare_func = thread_resume_prepare_func;
+	cb.thread_resume_func = thread_resume_func;
+	cb.thread_initiate_parking = thread_initiate_parking;
+	cb.thread_dissolve_parking = thread_dissolve_parking;
+	cb.thread_detach_func = thread_detach_function;
+#endif
 
-	mono_counters_register ("GC Maps size",
-							MONO_COUNTER_GC | MONO_COUNTER_INT, &gc_maps_size);
+	mono_gc_set_gc_callbacks (&cb);
 }
 
-#else
-
-void
-mini_gc_init (void)
-{
-}
-
-void
-mini_gc_init_gc_map (MonoCompile *cfg)
-{
-}
-
-void
-mini_gc_create_gc_map (MonoCompile *cfg)
-{
-}
-
-#endif
Index: mono/mini/mini-gc.h
===================================================================
--- mono/mini/mini-gc.h	(revision 159364)
+++ mono/mini/mini-gc.h	(working copy)
@@ -5,8 +5,4 @@
 
 void mini_gc_init (void) MONO_INTERNAL;
 
-void mini_gc_init_gc_map (MonoCompile *cfg) MONO_INTERNAL;
-
-void mini_gc_create_gc_map (MonoCompile *cfg) MONO_INTERNAL;
-
 #endif
Index: mono/mini/driver.c
===================================================================
--- mono/mini/driver.c	(revision 159364)
+++ mono/mini/driver.c	(working copy)
@@ -56,6 +56,7 @@
 #include <locale.h>
 #include "version.h"
 #include "debugger-agent.h"
+#include "mini-gc.h"
 
 static FILE *mini_stats_fd = NULL;
 
@@ -1638,6 +1639,10 @@
 	}
 #endif
 
+	/* This needs to be called before mono_gc_base_init
+	 */
+	mini_gc_init ();
+
 	/*
 	 * This must be called before mono_debug_init(), because the
 	 * latter registers GC roots.
Index: mono/arch/x86/x86-codegen.h
===================================================================
--- mono/arch/x86/x86-codegen.h	(revision 159364)
+++ mono/arch/x86/x86-codegen.h	(working copy)
@@ -2049,6 +2049,12 @@
 	} while (0)
 
 
+#define x86_int_trap(inst) \
+	do { \
+		*(inst)++ = (unsigned char) 0xCC; \
+	} while (0)
+ 
+#define INT_TRAP_INSTRUCTION_BYTE (0xCC)
 
 #endif // X86_H
 
